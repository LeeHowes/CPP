<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0072)file:///Users/lwh/Dropbox%20(Facebook)/C++/Mailings/2017-06/p0667r0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>TBD: Simplifying continuations with std::future</title>
<style type="text/css">
html { line-height: 135%; }
ins { background-color: #DFD; }
del { background-color: #FDD; }
</style>
</head>
<body>
<table>
        <tbody><tr>
                <th>Doc. No.:</th>
                <td>WG21/TBD</td>
        </tr>
        <tr>
                <th>Date:</th>
                <td>2017-09-06</td>
        </tr>
        <tr>
            <th>Authors:</th><td>Lee Howes <a href="mailto:lwh@fb.com">lwh@fb.com</a>, Andrii Grynenko <a href="mailto:andrii@fb.com">andrii@fb.com</a></td>
        </tr>
        <tr>
                <th>Reply-to:</th>
                <td>Lee Howes</td>
        </tr>
        <tr>
                <th>Email:</th>
                <td><a href="mailto:lwh@fb.com">lwh@fb.com</a></td>
        </tr>
        <tr>
                <th>Audience:</th>
                <td>SG1</td>
        </tr>
</tbody></table>
<h1>Continuations and std::future</h1>

<h2>Background</h2>
In the Concurrency TS, <code>std::future</code> was augmented with support for continuations. However, the feedback leading up to and during the recent meeting in Toronto was that the specification for continuation support in the TS was insufficient. The absence of support for executors made it hard to control. LWG2533 expressed concern about where the continuation is run, and other papers including P0667, P0679 and P0701 expressed concerns with various parts of the proposal. Much of this
feedback relates to the ongoing work on executors that is as yet incomplete. The continuation elements of the Concurrency TS were subsequently not merged into the C++20 standard draft at Toronto.

At Facebook we, like mamy companies, have considerable experience of using continuations on futures. Our folly library is widely used within the company, and is open source. Folly supports executors and continuations. From the widespread use of folly inside Facebook we have learned many lessons. One of the big lessons is very similar to that expressed in LWG2533: that it needs to be very well defined precisely where a continuation will run when applied to a Future. In the absence of a very
strong rule, there is an inherent non-determinism: I
<ul>
    <li>If the future is complete at the time of adding the continuation, will it run in the calling thread of execution?</li>
    <li>If the future is incomplete at the time of adding the continuation, is it possible for it to complete in the same thread of execution that completes the preceding task?</li>
    <li>Will the continuation always run in a well-defined thread-of-execution, whatever the completion state is of the future? To achieve this, the thread of execution has to be guaranteed to survive long enough to make this possible.</li>
</ul>

Our experience leads us to believe that an executor should always be available to any attempt to add a continuation to a future, and where the continuation runs should be explicitly defined by the rules of that executor. In this way everything is clean as long as the lifetime of the executor can be guaranteed (which is out of scope of this paper).

Always requiring specification of an executor is possible, but clumsy. During discussions in Toronto more than one person expressed a wish to allow a default executor, that would be used if none was provided to the call to <code>.then</code>. If this is allowed then we have further questions:
<ul>
    <li>Should the default executor be a global default. This will be suboptimal for cases where it makes more sense to allow the continuation task to run on same thread-of-execution as task that results in the future's result.</li>
    <li>Should an executor be embedded in the future, and hence a continuation added with <code>.then</code> would run on the same thread-of-execution as the future completes on? This would work well in many situations, but for libraries to safely return a future that did not allow the caller to run work on the library's internal threads-of-execution this might mean modifying the executor attached to the returned future before returning said future</li>
</ul>

The second option here is often used in Facebook's libraries. The result is that asynchronous libraries will require an executor to be passed into the library, so that the library can attach that continuation to the future before returning it to provide the clean execution boundary required. The cost of this is that executor parameters need to be widespread and intrude in places where they are not relevant.

Take a simple example of a library that gets a future and passes it into some other library:
<pre>
void myForwardingFunction() {
    Executor e;
    auto future = LibraryA::getFromSomewhere(&e, params);
    LibraryB::sendToSomewhere(future);
}
</pre>

In this case, why did <code>myForwardingFunction</code> need to know about an executor at all? How would we ever choose a reasonable excecutor here that guarantees forward progress and yet does not impose a high cost? In practice, <code>LibraryB</code> should use its own exector to run the continuation, but this is not something that <code>LibraryA</code> can rely on while providing a safe separation of concerns.

<h2>A simpler addition to std::future</h2>
We propose modifying std::future to add a <code>.via()</code> method that takes an executor. Via should take the <code>std::future</code> and return a new future type, yet to be defined but that can be roughly similar to <code>std::experimental::future</code>, that adds support for continuations using <code>.then</code> methods. We will call this <code>ThennableFuture</code> here to avoid bikeshedding. <code>ThennableFuture</code> should store its executor internally, which means that it is well-defined to add an overload of <code>.then</code> that takes no executor. It may
even make sense to remove the <code>.then</code> overloads that do take executors to make it absolutely explicit that at any point in the code, continuations are enqueued on the executor contained within the future.

We additionally add a conversion, possibly implicit, from ThennableFuture to <code>std::future</code>. 

In this world, <code>std::future</code> stays as the vocabulary type, with general day to day use unchanged. Our forwarding function as described above simplifies:

<pre>
void myForwardingFunction() {
    auto future = LibraryA::getFromSomewhere(params);
    LibraryB::sendToSomewhere(future);
}
</pre>

We no longer need to tell <code>LibraryA</code> what executor to return us a future on, which means that <code>myForwardingFunction</code> now does not need to know about executors at all. Why should it care? <code>LibraryA</code> did some work, <code>LibraryB</code> will do some more work dependent on <code>LibraryA</code>'s work. The forwarder need not know what that is, and in addition need not incur any extra cost of adding a shunt-type executor that exists purely to protect
<code>LibraryA</code> from its callers.

As <code>std::future</code> will be carrying potentially unexecuted tasks, to allow safe chaining it may be necessary to include a type-erased executor as a field in the future core, but this appears to be an implementation detail.

We are then proposing modifying <code>std::future</code> to add:
<pre>
template<class T> class Future {
    ...
    /* implicit */
    Future(ThennableFuture<T>&&);

    ...

    ThennableFuture<T> via(ExecutorT);

    ...
};
</pre>


<h2>Templating the new future</h2>
If we continue to use <code>std::future</code> as the vocabulary type for APIs, we can consider templating our new future on the executor type for efficiency. So our new future then becomes typed:

<pre>
template<class T, class ExecutorT> class ThennableFuture;
</pre>

What is interesting about this is that it means we do not pass a future that supports continuations and yet has an unknown executor across library boundaries. This is important because it also means we do not pass a future that supports continuations and has an unknown forward progress guarantee for those continuations.

To <code>std::future</code> we add:

<pre>
template<class T> class Future {
    ...
    template<class ExecutorT>
    /* implicit */
    Future(ThennableFuture<T, ExecutorT>&&);

    ...

    ThennableFuture<T, ExecutorT> via(ExecutorT);

    ...
};
</pre>

<h2>Forward progress guarantees</h2>
<h2>Boost blocking and deferred execution</h2>
TODO:Even though the future does not expose the executor to continuations, it is still there. This means you can push some work onto the caller if it makes sense, still without exposing an API for that purpose.
TODO:Note in particular that .via needs to boost block, along with .get, but that .then need not in this design.

</p></body></html>
