<pre class='metadata'>
Title: A more flexible FutureContinuation concept
Shortname: PTODO
URL: wg21.link/PTODO
Revision: 0
Audience: SG1
Status: D
Group: WG21
!Source: <a href="https://github.com/LeeHowes/CPP/blob/master/future_continuation.bs">https://github.com/LeeHowes/CPP/blob/master/future_continuations.bs</a>
No Abstract: yes
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Editor: Lee Howes, Facebook, lwh@fb.com
</pre>

Introduction {#intro}
=====================
[p0443](https://wg21.link/P0443) defines interfaces for executors and the continuation functions passed to them.
The current design of the continuation functions passed to then_execute are based on invokability.

In essence the continuations have an interface similar to:
```
struct callable {
  R operator()(T);
  R operator()(exception_arg_t, e);
};
```

where either function is optional, and in that situation the other operation will act as a passthrough.
One reason for designing the API in this way is to allow a simple lambda function to be passed to `then_execute`:
```
e.then_execute([](T value){return value;}, input_future);
```

The downsides of this design are twofold:
 * The description of the continuation is based on invokability. There is then potential for errors that would easily slip through code review, and silently cause unexpected runtime behaviour.
 * The parallel pipe mechanismm of describing the continuation removes the ability to catch and pass an exception from the value operator, or to log and passthrough an exception from the exception operator without rethrowing the exception.

On the first point, consider the following struct that an author might write in an attempt to handle both values and exceptions at some stage in the pipeline:
```
struct callable {
  int operator()(int value) {
    return value + 1;
  }
  int operator()(std::exception_ptr e) {
    return 0;
  }
};
```

This is a trivial example of ignoring the precise exception and attempting to recover.
Note that the reality here, based on the [p0443](https://wg21.link/P0443) definition is that the exception function is not callable as the `EXCEPTIONAL` case.
It will therefore not be called and an exception will bypass.
In effect, this struct is semantically equivalent to:
```
struct callable {
  int operator()(int value) {
    return value + 1;
  }
  int operator()(exception_arg_t, std::exception_ptr e) {
    std::rethrow_exception(e);
  }
};
```

where we have silently lost our recovery, passed the error through with potentially negative consequences.
There is no compilation or runtime error here, and this kind of problem could be hard to catch in code review.

On the second point, consider an exception handler that only exists to log that an exception reached a point in the stream:
```
struct callable {
  int operator()(int value) {
    return value + 1;
  }
  int operator()(exception_arg_t, std::exception_ptr e) {
    std::cerr << "Have exception\n";
    std::rethrow_exception(e);
  }
};
```

This is an expensive means of doing nothing to the exception.
With potential extensions to `std::exception_ptr` that would allow peeking at the exception without rethrow, there is a wide scope of lost optimisation here.

What we might prefer, would be to implement this as:
```
struct callable {
  int operator()(int value) {
    return value + 1;
  }
  std::exception_ptr operator()(exception_arg_t, std::exception_ptr e) {
    std::cerr << "Have exception\n";
    return e;
  }
};
```

but then we lose the ability to recreate the value.

We consider these two flaws, one of safety and the other of flexibility, as unfortunate limitations of a low-level API like executors.


Requirements
=====================
If we look at some example continuation constructions based on those in [PTODO] we can see what kind of functionality we might want here.

### then_value
This is the simple passthrough of the exception, while applying some operation to the value.

The callback we expect to create looks like:
```
then_value([](T value){operation(value);});
```

As a flow diagram, something like:
```
set_value --------- Perform Operation ----- return_value

set_exception ----------------------------- return_exception
```

### then_error
The equivalent where we apply some operation to the exception, but not the value.
A good example of this might be error recovery. Note that in this case we are breaking the exception chain.
The callback we expect to create looks like:
```
then_error([](std::exception_ptr e){
  try {
   std::rethrow_exception(e);
  } catch(recoverable_exception) {
    return 0;
  } catch(...) {
    std::rethrow_exception(std::current_exception());
  }});
```

Or:
```
set_value -------------------------------------------------------/----- return_value
                                            /----- Recover -----/
set_exception ----- Perform Operation ----- |
                                            \----- Do not recover ----- return_exception
```

Note that in this case we rethrow twice. Logically the first is just to check the exception type.
The second is just returning the exception and relying on external logic to catch as we do not have two outputs in the syntax.
Improvements to `exception_ptr` (along the lines of folly's [`exception_wrapper`](https://github.com/facebook/folly/blob/master/folly/ExceptionWrapper.h)) could mitigate the first.
Ability to return either an `exception_ptr` or a `T` from the error case could remove the second throw.

### then_variant
Here our operation might take a variant of a value and an exception so that we can write a single function that decides what to do:
The callback we expect to create looks like:
```
then_variant([](std::variant<T, std::exception_ptr> v){operation(v);});
```

Diagrammatically:
```
set_value -----\                             /----- return_value
               |----- Perform Operation -----|
set_exception -/                             \----- return_exception
```

This is a very common pattern in Facebook's code where `folly::Try<T>`, which carries a value and exception, is the preferred means of parameterising future continuations.

### then_value_logging_error
Here we merely log the existence of an error, and pass it through.
We might write this as:
```
then_exception_filter(
  [](T value){operation(v);},
  [](std::exception_ptr e){std::cerr << "Have an exception\n"; return e;});
```

Here we have a very simple pair of parallel operations:
```
set_value --------- Perform Operation ----- return_value

set_exception ----- Log ------------------- return_exception
```
Note though that it relies on allowing return of an `exception_ptr` from the exception path to do this without a throw.


Concept
=====================
As an alternative way of thinking about this problem we should step back and think about what we want from the solution.
Fundamentally, a continuation is a function from a value input or an exceptional input, to a value output or an exceptional output.
<pre class='railroad'>
Choice:
 T: set_value
 T: set_exception
N: Perform operation
Choice:
 T: return_value
 T: return_exception
</pre>


TODO: Fundamentally we need something that has a promise as input, and a promise as output, and where the value and error operations can be mixed based on the implementation
This is fully general.

TODO: So what does this look like? Because the Promises are both concepts, not types, we need to be able to generate this code. So given that we define the input promise,
that is the task itself, what we need is a way to take the output promise as input. We need to construct a usable task from some partial task, taking a promise as input.
The continuation, then, is a function of a Promise to a Promise.

Examples
=====================
In this section we show the fundamental examples and what they look like as a
function of a promise to a promise, with code hosted on godbolt to show it compiles and that it optimises away when necessary.

### then_value
[then_value optimising away](https://godbolt.org/g/RLb4ft)

### then_error
TODO: godbolt

### then_variant
TODO: godbolt

### then_value_logging_error
TODO: godbolt

Proposed New Wording
====================

### Promise


### FutureContinuation
